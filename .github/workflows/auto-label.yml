name: Auto Label

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

permissions:
  contents: read
  pull-requests: write

jobs:
  auto-label:
    runs-on: ubuntu-latest
    steps:
      - name: Auto-label PR
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            // Size label thresholds
            const SIZE_THRESHOLDS = {
              SMALL: { maxFiles: 2, maxChanges: 20 },
              MEDIUM: { maxFiles: 5, maxChanges: 100 }
            };

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });

            // Skip labeling for draft PRs
            if (pr.draft) {
              console.log('PR is in draft state. Skipping auto-labeling.');
              return;
            }

            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });

            // Skip if there are no files changed
            if (files.length === 0) {
              console.log('No files changed. Skipping auto-labeling.');
              return;
            }

            // Define patterns for generated/lockfiles to exclude from size calculation
            const generatedFilePatterns = [
              // Lock files
              /pnpm-lock\.yaml$/,
              /package-lock\.json$/,
              /yarn\.lock$/,
              
              // Build artifacts
              /\.tsbuildinfo$/,
              /\.turbo\//,
              /dist\//,
              /\.next\//,
              
              // Dependencies
              /node_modules\//,
              /\.pnp\.(c?js|loader\.mjs)$/,
              /\.yarn\//,
              
              // Cache directories
              /\.cache\//,
              
              // Test artifacts
              /playwright-report\//,
              /test-results\//,
              /coverage\//,
              
              // Generated service workers and static files
              /mockServiceWorker\.js$/,
              /storybook-static\//,
            ];

            // Helper function to check if a file is generated
            const isGeneratedFile = (filename) => {
              return generatedFilePatterns.some(pattern => pattern.test(filename));
            };

            // Filter out generated files for meaningful change calculation
            const meaningfulFiles = files.filter(file => !isGeneratedFile(file.filename));

            // Calculate statistics (excluding generated files)
            const meaningfulFileCount = meaningfulFiles.length;
            const meaningfulChanges = meaningfulFiles.reduce((sum, file) => sum + file.changes, 0);

            // If all files are generated, skip size labeling but still add area/tech labels
            const hasOnlyGeneratedFiles = meaningfulFiles.length === 0;

            // Detect area labels based on directories (use all files to track all affected areas)
            const areaLabels = new Set();
            files.forEach(file => {
              if (file.filename.startsWith('apps/web/')) areaLabels.add('area: web');
              if (file.filename.startsWith('apps/admin/')) areaLabels.add('area: admin');
              if (file.filename.startsWith('apps/batch/')) areaLabels.add('area: batch');
              if (file.filename.startsWith('apps/insights/')) areaLabels.add('area: insights');
            });

            // Detect tech labels based on file extensions and directories (use all files)
            const hasPython = files.some(file => file.filename.endsWith('.py'));
            const hasSupabase = files.some(file => file.filename.startsWith('supabase/'));

            // Detect documentation changes (use all files)
            const isDocumentation = files.some(file => 
              file.filename.endsWith('.md') || 
              file.filename.endsWith('.mdx') || 
              file.filename.startsWith('docs/')
            );

            // Collect labels to add
            const labelsToAdd = [...Array.from(areaLabels)];

            if (hasPython) {
              labelsToAdd.push('tech: python');
            }

            if (hasSupabase) {
              labelsToAdd.push('tech: supabase');
            }

            if (isDocumentation) {
              labelsToAdd.push('type: Documentation');
            }

            // Determine size label (only if not already set and has meaningful changes)
            const existingLabels = pr.labels.map(label => label.name);
            const hasSizeLabel = existingLabels.some(label => label.startsWith('size: '));

            if (!hasSizeLabel && !hasOnlyGeneratedFiles) {
              let sizeLabel;
              if (meaningfulFileCount <= SIZE_THRESHOLDS.SMALL.maxFiles && 
                  meaningfulChanges <= SIZE_THRESHOLDS.SMALL.maxChanges) {
                sizeLabel = 'size: S';
              } else if (meaningfulFileCount <= SIZE_THRESHOLDS.MEDIUM.maxFiles && 
                         meaningfulChanges <= SIZE_THRESHOLDS.MEDIUM.maxChanges) {
                sizeLabel = 'size: M';
              } else {
                sizeLabel = 'size: L';
              }
              labelsToAdd.push(sizeLabel);
              console.log(`Size calculation: ${meaningfulFileCount} files, ${meaningfulChanges} changes -> ${sizeLabel}`);
            } else if (hasOnlyGeneratedFiles) {
              console.log('All changed files are generated/lockfiles. Skipping size label.');
            }

            // Add labels if any
            if (labelsToAdd.length > 0) {
              console.log('Adding labels:', labelsToAdd);
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: labelsToAdd,
              });
            } else {
              console.log('No labels to add');
            }

